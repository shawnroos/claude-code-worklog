package models

import "time"

// GitContext represents the git context for work items
type GitContext struct {
	Branch           string `json:"branch"`
	Worktree         string `json:"worktree"`
	RemoteURL        string `json:"remote_url,omitempty"`
	WorkingDirectory string `json:"working_directory"`
}

// SimilarityMetadata represents metadata for similarity matching
type SimilarityMetadata struct {
	Keywords        []string `json:"keywords"`
	FeatureDomain   string   `json:"feature_domain"`
	TechnicalDomain string   `json:"technical_domain"`
	CodeLocations   []string `json:"code_locations"`
	StrategicTheme  string   `json:"strategic_theme"`
}

// WorkItemReference represents a reference to another work item
type WorkItemReference struct {
	TargetID         string  `json:"target_id"`
	SimilarityScore  float64 `json:"similarity_score"`
	RelationshipType string  `json:"relationship_type"`
	Confidence       float64 `json:"confidence"`
	AutoGenerated    bool    `json:"auto_generated"`
}

// WorkItemMetadata represents metadata for work items
type WorkItemMetadata struct {
	PlanSteps             []string               `json:"plan_steps,omitempty"`
	DecisionRationale     string                 `json:"decision_rationale,omitempty"`
	ImplementationNotes   string                 `json:"implementation_notes,omitempty"`
	Priority              string                 `json:"priority,omitempty"`
	Tags                  []string               `json:"tags,omitempty"`
	PromotedFromFuture    bool                   `json:"promoted_from_future,omitempty"`
	PromotedFromHistory   bool                   `json:"promoted_from_history,omitempty"`
	PromotedFromGroup     string                 `json:"promoted_from_group,omitempty"`
	ArchivedFrom          string                 `json:"archived_from,omitempty"`
	ArchivedAt            string                 `json:"archived_at,omitempty"`
	SimilarityMetadata    *SimilarityMetadata    `json:"similarity_metadata,omitempty"`
	SmartReferences       []WorkItemReference    `json:"smart_references,omitempty"`
}

// WorkItem represents a work item (todo, plan, proposal, etc.)
type WorkItem struct {
	ID        string            `json:"id"`
	Type      string            `json:"type"`
	Content   string            `json:"content"`
	Status    string            `json:"status"`
	Context   GitContext        `json:"context"`
	SessionID string            `json:"session_id"`
	Timestamp string            `json:"timestamp"`
	Metadata  *WorkItemMetadata `json:"metadata,omitempty"`
}

// Finding represents a finding or research result
type Finding struct {
	ID               string `json:"id"`
	Type             string `json:"type"`
	Content          string `json:"content"`
	Context          string `json:"context"`
	ToolName         string `json:"tool_name"`
	Timestamp        string `json:"timestamp"`
	SessionID        string `json:"session_id"`
	WorkingDirectory string `json:"working_directory"`
	GitBranch        string `json:"git_branch"`
	GitWorktree      string `json:"git_worktree"`
}

// SessionSummary represents a session summary
type SessionSummary struct {
	SessionID      string     `json:"session_id"`
	Timestamp      string     `json:"timestamp"`
	GitContext     GitContext `json:"git_context"`
	CompletedTodos int        `json:"completed_todos"`
	PendingTodos   int        `json:"pending_todos"`
	FindingsCount  int        `json:"findings_count"`
	PlansCreated   int        `json:"plans_created"`
	ProposalsMade  int        `json:"proposals_made"`
	KeyDecisions   []string   `json:"key_decisions"`
	Outcomes       []string   `json:"outcomes"`
}

// WorkState represents the current work state
type WorkState struct {
	CurrentSession string          `json:"current_session"`
	ActiveTodos    []WorkItem      `json:"active_todos"`
	RecentFindings []Finding       `json:"recent_findings"`
	SessionSummary *SessionSummary `json:"session_summary,omitempty"`
}

// FutureWorkItem represents a future work item
type FutureWorkItem struct {
	ID                 string             `json:"id"`
	Type               string             `json:"type"`
	OriginalType       string             `json:"original_type"`
	Content            string             `json:"content"`
	SimilarityMetadata SimilarityMetadata `json:"similarity_metadata"`
	Context            struct {
		DeprioritizedFrom   string `json:"deprioritized_from"`
		DeprioritizedDate   string `json:"deprioritized_date"`
		DeprioritizedReason string `json:"deprioritized_reason"`
		SuggestedGroup      string `json:"suggested_group"`
	} `json:"context"`
	GroupingStatus       string `json:"grouping_status"`
	PriorityWhenPromoted string `json:"priority_when_promoted"`
	CreatedAt            string `json:"created_at"`
}

// FutureWorkGroup represents a group of future work items
type FutureWorkGroup struct {
	ID              string   `json:"id"`
	Name            string   `json:"name"`
	Description     string   `json:"description"`
	Items           []string `json:"items"`
	SimilarityScore float64  `json:"similarity_score"`
	StrategicValue  string   `json:"strategic_value"`
	EstimatedEffort string   `json:"estimated_effort"`
	ReadinessStatus string   `json:"readiness_status"`
	CreatedDate     string   `json:"created_date"`
	LastUpdated     string   `json:"last_updated"`
}

// Helper methods

// GetPriority returns the priority of a work item, defaulting to "medium"
func (w *WorkItem) GetPriority() string {
	if w.Metadata != nil && w.Metadata.Priority != "" {
		return w.Metadata.Priority
	}
	return "medium"
}

// GetTimestamp returns the timestamp as a time.Time
func (w *WorkItem) GetTimestamp() time.Time {
	if t, err := time.Parse(time.RFC3339, w.Timestamp); err == nil {
		return t
	}
	return time.Time{}
}

// GetDisplayStatus returns a formatted status string
func (w *WorkItem) GetDisplayStatus() string {
	switch w.Status {
	case "pending":
		return "Pending"
	case "in_progress":
		return "In Progress"
	case "completed":
		return "Completed"
	default:
		return w.Status
	}
}

// GetDisplayType returns a formatted type string
func (w *WorkItem) GetDisplayType() string {
	switch w.Type {
	case "todo":
		return "Todo"
	case "plan":
		return "Plan"
	case "proposal":
		return "Proposal"
	case "finding":
		return "Finding"
	case "report":
		return "Report"
	case "summary":
		return "Summary"
	default:
		return w.Type
	}
}

// HasSmartReferences returns true if the work item has smart references
func (w *WorkItem) HasSmartReferences() bool {
	return w.Metadata != nil && len(w.Metadata.SmartReferences) > 0
}

// GetSmartReferenceCount returns the number of smart references
func (w *WorkItem) GetSmartReferenceCount() int {
	if w.Metadata == nil {
		return 0
	}
	return len(w.Metadata.SmartReferences)
}